simSpatialCoal <- function(theta_sigma, theta_Y_r, theta_Y_k, theta_rate, EnvMatrix, nbLocus, dataCoord){
  
}
 
if(anyNA(dataCoord)){ 
  stop("unknown localizations (NA) in simSpatialCoal. Please verify if genetic data coordinates are inside raster extent")
}
  
# Initialize the final genetic results table
        
geneticResults <- matrix(data=NA, nrow=nrow(GeneticData), ncol=numberOfLoci)

# Construct carrying capacity matrix :
kMatrix <- apply(envMatrix, c(1,2), constant, Y = theta_Y_k)
kMatrix <- round(kMatrix)

# Prevent impossible transition :
if( sum(kMatrix) <= 0){
  stop(paste("The parameters values for niche models led to null carrying capacity over all cells of the landscape :
             coalescence is impossible to simulate"))
}

# Constructgrowth rate matrix :
rMatrix <- apply(envMatrix, c(1,2), constant, Y = theta_Y_r)

# Prevent impossible transition :
if( sum(rMatrix) <= 0){
  stop(paste("The parameters values for niche models led to null growth rate over all cells of the landscape : 
             coalescence is impossible to simulate"))
}

# Construct migration matrix :
kernelMatrix <- computeDispersionKernel(dispersionFunction = getFunctionDispersion(ParamList),
                                        distanceMatrix = distMat, 
                                        args=getArgsListDispersion(simulation = x, ParamList = ParamList))

migrationMatrix <- migrationRateMatrix(kernelMatrix)

# Get transition matrix :
transitionBackward <- transitionMatrixBackward(r = values(rasR), K = values(rasK), migration = migrationMatrix)

# number of  tipNodes
numNodes <- length(localizationData)

# Compute the maximal number of coalescence events
maxCoalEvent <- numNodes - 1

### LOOP ON LOCI >>>>>>>>>>>>>>>>>

for(locus in 1:numberOfLoci){ # locus=1
  
  # Get the stepValue of the locus under concern
  stepValue <- stepValueOfLoci[locus]
  
  # coalescent informations : (time of coalescence, Child 1, Child 2, Parent, Branch Length, mutation nbr, resultant, genet values)
  coal <- matrix(data = NA, nrow = maxCoalEvent, ncol = 8)    
  
  # launch the coalescent
  coal[,c(1:4)] <- coalescentCore(tipDemes = localizationData, 
                                  transitionBackward = transitionBackward, 
                                  N = round(values(rasK)))
  
  # Create a matrice for branches (in columns : Child/Parent/Branch length/Number of mutation/Resultant)
  branchMat <- matrix(NA, nrow = (maxCoalEvent)*2, ncol = 5)
  
  # Fill child -> Parent information (decoupling children nodes)
  branchMat[,c(1,2)] <- rbind(coal[,c(2,4)] , coal[,c(3,4)])
  
  # time of apparition of child node
  timeC <- vapply(X = branchMat[,1],
                  FUN = function(x, coal){
                    # find position in coalescence table
                    line <- which(coal[, 4] == x)
                    if(length(line) == 1){
                      # it's ok : get time
                      t <- coal[line, 1] 
                    }else if(length(line) == 0) {
                      # node is an initial nod (tip node)
                      t <- 0                          
                    }else{
                      # it's really NOT ok
                      stop("error in filling branch lengths in coalescent : 
                           several times of apparition for one node seem to appear : 
                           please verify code")
                    }
                    return(t)
                    },
                  coal = coal,
                  FUN.VALUE = c(1))
  
  # time of apparition of parent node
  timeP <- vapply(X = branchMat[,2],
                  FUN = function(x, coal){
                    # find position in coalescence table
                    line <- which(coal[, 4] == x)
                    if(length(line) == 1){
                      # it's ok : get time
                      t <- coal[line, 1] 
                    }else if(length(line) == 0) {
                      # node is an initial nod (tip node)
                      t <- 0                          
                    }else{
                      # it's really NOT ok
                      stop("error in filling branch lengths in coalescent : 
                           several times of apparition for one node seem to appear : 
                           please verify code")
                    }
                    return(t)
                    },
                  coal = coal,
                  FUN.VALUE = c(1))
  
  # add branch length
  branchMat[,3] <- timeP - timeC        
  
  # add mutation number
  branchMat[,4] <- vapply(X = branchMat[,3],
                          FUN = function(x){rpois(n = 1, lambda = mutationRate*x)},
                          FUN.VALUE = c(1))
  
  # add resultant 
  branchMat[,5] <- resultantFunction(nbrMutations = branchMat[,4],
                                     stepValue = stepValue,
                                     mutationModel = getFunctionMutation(ParamList = ParamList),
                                     args = getArgsListMutation(simulation = x, ParamList = ParamList ))
  
  # add genetic values
  values <- rep(NA, times = numNodes + maxCoalEvent)
  values[length(values)] <- initialGenetValue
  for(n in seq(from = length(values)-1, to =1, by = -1 )){
    # find the line of the focal node
    focal <- which(branchMat[,1] == n)
    # find the resultant
    res <- branchMat[focal, 5]
    # find the genetic value of the parent
    values[n] <- values[branchMat[focal, 2]] +res
  }
  
  # Record the genetic data
  geneticResults[,locus] <- values[1:numNodes]        
  
                  } # END OF LOOP OVER LOCI <<<<<<<<<<<<<

# write results of genetic data 
fname = paste(getwd(),"/SimulResults/", "Genetics_", x , ".txt", sep="")
write.table(geneticResults, file=fname)
        



coalescentCore <- function(tipDemes, transitionBackward, N){
  # Simulate a genealogy backward in the time, accross demes
  # 
  # Args:
  #   tipdDemes: vector of the demes in which each node is found a time 0.
  #   transitionBackward: matrix of transition backward in time
  #   N a vector of population sizes
  #
  # Returns: 
  #   A matrix describing the coalescence events : time/childNode1/childNode2/parentNode
  
  ###### INITIALISATION
  time <- 0
  events <- 0
  headNode <- length(tipDemes)
  maxCoalEvent <- length(tipDemes) - 1
  nodesState <- c(tipDemes, rep(NA, maxCoalEvent))
  
  # coalescent informations : (time of coalescence, Child 1, Child 2, Parent)
  coalescent <- matrix(data = NA, nrow = maxCoalEvent, ncol = 4)
  
  ###### REPEAT UNTIL TOTAL COALESCENCE
  while (is.na(tail(nodesState, n=1))){
    time <- time +1
    
    #### MIGRATION
    nodesState[!is.na(nodesState)] <- vapply(X = nodesState[!is.na(nodesState)],
                                             FUN = function(x, N, transitionBackward)
                                             {sample( length(N), size = 1, prob = c(transitionBackward[x,]) )},
                                             N = N, transitionBackward = transitionBackward,
                                             FUN.VALUE = c(1))
        
    ####### CANDIDATES NODES FOR COALESCENCE
    # for active nodes, i.e which are not coded by NA : 
    activeNodes <- which(!is.na(nodesState))
    activeDemes <- nodesState[activeNodes]
    # gives indices of the demes that are duplicated
    dup <- which(duplicated(activeDemes) | duplicated(activeDemes, fromLast= TRUE))
    # gives the demes in which more than one node exist :
    demes <- unique(activeDemes[dup])
    # gives a list of nodes who can perhaps coalesce 
    candidates <- lapply(X = demes,
                         FUN = function(x, nodesState){which(nodesState == x)},
                         nodesState = nodesState)
    
    ####### COALESCENCE
    if(length(candidates) > 0){
      
      for(x in seq(from = 1, to = length(candidates))){ # x <- 1
        
        focalDeme <- demes[x]
        # /!\ If N=0, the nodes would automatically coalesce (parents nÂ°0 for everyone) -> make sure this does not happen !
        if(N[focalDeme]==0){stop(paste("in coalescentCore you are trying to coalesce in an empty deme : in deme", x ,", N=0"))}
        
        # Attribute parents (among N possible parents) to each node present in the deme
        parents <- sample(N[focalDeme], size = length(candidates[[x]]), replace = TRUE) # parents[1] <- parents[2]
        # Test for equality of parents :
        anonymous <- which(duplicated(parents) | duplicated(parents, fromLast= TRUE))
        
        # If nodes have same parent node
        if(length(anonymous) > 1) {
          
          # sample in the candidates nodes who will coalesce
          children <- sample(x = candidates[[x]], size = length(anonymous), replace = FALSE)
          # number of new coalescent events
          nEvents <- length(children) -1
          
          # Move header node forward, and skip ephemeral ones
          headNode <- headNode + nEvents
          # Precise the deme were araised the new node
          nodesState[headNode] <- focalDeme
          # Shut down children nodes
          nodesState[children] <- NA
          
          lines <- seq(from = events+1, to = events + nEvents)
          parentNodes <- seq(from = headNode - nEvents + 1, to = headNode )
          # Fill time
          coalescent[lines, 1] <- rep(x = time, times = nEvents)
          # Fill Child1
          coalescent[lines, 2] <- c(children[1], parentNodes[-length(parentNodes)])
          # Fill Child2
          coalescent[lines, 3] <- c(children[-1])
          # Fill parents
          coalescent[lines, 4] <- parentNodes
          events <- events + nEvents
          
        } # end of if there are coaelescing nodes
      } # end of for loop over demes
    } # end of if there are co occuring nodes in the same deme
  } # end of while coalescence is not complete
  return(coalescent)
}

timeFinder <- function(x, coal){
  # Find time at which a node appeared for the first time. Function used to compute branch length
  #
  # Args:
  #   x : the ID of the node
  #   coal : the table returned by coalescentCore
  #
  # Returns :
  #   The time at which the node x appeared for the first time
  
  # find position in coalescence table
  line <- which(coal[, 4] == x)
  if(length(line) == 1){
    # it's ok : get time
    t <- coal[line, 1] 
  }else if(length(line) == 0) {
    # node is an initial nod (tip node)
    t <- 0                          
  }else{
    # it's really NOT ok
    stop("error in filling branch lengths in coalescent : 
                                 several times of apparition for one node seem to appear : 
                                 please verify code")
  }
  return(t)
}

coalescent_2_newick <- function(coalescent)
{
  # coalescent_2_newick
  # function that converts coalescent to newick format tree
  # argument: coalescent list 
  # value : newwick foramt tree
  # 
  # Example
  # trB = matrix(c(1/4,1/2,1/4,0,1/3,1/3,1/6,1/6,1/2,1/4,1/8,1/8,1/5,2/5,2/5,0),nrow=4,ncol=4,byrow=TRUE)
  # trF = matrix(c(1/4,1/2,1/2,1/8,1/3,1/3,1/6,1/6,1/2,1/4,1/8,1/8,0,0,2/5,0),nrow=4,ncol=4,byrow=TRUE)
  # K=c(4,3,1,5)
  # tipsDemes = c(1,4,2,2,1,1,2,3);names(tipsDemes)=1:8
  # Coalescent = simul_coalescent_only(tipDemes=tipsDemes,transitionForward=trF,transitionBackward=trB,K=K)
  # coalescent_2_newick(Coalescent)

  tree=paste(" ",coalescent[[1]][[length(coalescent)]]$new_node," ",sep="")
  for (i in length(coalescent):1)
  {
    Time = coalescent[[1]][[i]]$time
    coalesc <- as.character(coalescent[[1]][[i]]$coalescing)
    tree <- str_replace(tree,paste(" ",as.character(coalescent[[1]][[i]]$new_node)," ",sep=""),paste(" ( ",paste(" ",coalesc," :",coalescent[[1]][[i]]$br_length,collapse=" ,",sep=""),") ",sep=""))
  }
  tree <- gsub(" ","",paste(tree,";",sep=""))
  tree
}


plotCoalescentGenetics <- function(coalescent,genetic_table,with_landscape=FALSE,legend_right_move=-.2)
{
  # function that plots a coalecent, with tips demes as specific color
  # argument: coalescent list 
  #
  # 
  # Example
  # trB = matrix(c(1/4,1/2,1/4,0,1/3,1/3,1/6,1/6,1/2,1/4,1/8,1/8,1/5,2/5,2/5,0),nrow=4,ncol=4,byrow=TRUE)
  # trF = matrix(c(1/4,1/2,1/2,1/8,1/3,1/3,1/6,1/6,1/2,1/4,1/8,1/8,0,0,2/5,0),nrow=4,ncol=4,byrow=TRUE)
  # K=c(4,3,1,5)
  # tipsDemes = c(1,4,2,2,1,1,2,3);names(tipsDemes)=1:8
  # Coalescent = simul_coalescent_only(tipDemes=tipsDemes,transitionForward=trF,transitionBackward=trB,K=K)
  # plotCoalesentGenetics(coalescent_2_newick(Coalescent),tipDemes,legend_right_move=.2)
  
  par(mfrow=c(1,1),oma=c(0,0,0,4),xpd=TRUE)
  tipcells <- tipDemes[as.numeric(read.tree(text=coalescent_2_newick(coalescent))$tip.label)]
   #tipcells <- geneticData$Cell_numbers[as.numeric(coalescent_2_phylog(coalescent)$tip.label)]
  tipcols = rainbow(ncell(rasK))[tipcells]
  phylog_format_tree <- coalescent_2_phylog(coalescent)
  phylog_format_tree$tip.label <- paste(phylog_format_tree$tip.label,genetic_table[order(genetic_table$coalescing)[as.numeric(phylog_format_tree$tip.label)],"genetic_value"],sep=":")
  plot(phylog_format_tree,direction="downward",tip.color=tipcols)
  legend("topright", title="demes", cex=0.75, pch=16, col=tipcols[!duplicated(tipcols)], legend=tipcells[!duplicated(tipcols)], ncol=2, inset=c(legend_right_move,0))
  if (with_landscape) {plot(rasK)}
}